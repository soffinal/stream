# @soffinal/stream - LLM Context

## Library Overview

@soffinal/stream is a TypeScript library for building type-safe, reactive event streams. It provides primitives for creating reusable components with event-driven architecture.

## Core Primitives

### Stream<T>

The fundamental building block. A stream can:
- **Push values**: `stream.push(value1, value2, ...)`
- **Listen to values**: `stream.listen((value) => { ... })`
- **Async iterate**: `for await (const value of stream) { ... }`
- **Transform**: `stream.pipe(transformer)`

### Constructor Patterns

```typescript
// Empty stream (push-based)
new Stream<T>()

// Async generator (pull-based, lazy)
new Stream<T>(async function* () {
  for await (const value of source) {
    yield value;
  }
})

// From another stream
new Stream<T>(sourceStream)
```

## Transformer Architecture

### What is a Transformer?

A transformer is a function that takes a stream and returns a new stream:

```typescript
type Transformer<T, U> = (source: Stream<T>) => Stream<U>
```

### Simple Transformers (Composable from Primitives)

Use existing transformers like `map`, `filter`:

```typescript
// Take first N values
const take = <T>(n: number) =>
  filter<T, { count: number }>({ count: 0 }, (state, value) => {
    if (state.count >= n) return;
    return [true, { count: state.count + 1 }];
  });

// Running sum
const scan = <T, U>(fn: (acc: U, value: T) => U, initial: U) =>
  map<T, { acc: U }, U>({ acc: initial }, (state, value) => {
    const newAcc = fn(state.acc, value);
    return [newAcc, { acc: newAcc }];
  });
```

### Complex Transformers (Async Generator Pattern)

For timing-based or complex state management, use the async generator pattern:

```typescript
const debounce = <T>(ms: number) => (source: Stream<T>) => {
  const output = new Stream<T>(async function* () {
    let timer: any = null;

    for await (const value of source) {
      clearTimeout(timer);
      timer = setTimeout(() => output.push(value), ms);
    }
  });

  return output;
};
```

**Key insight**: The generator iterates the source, manages state, and pushes to output when ready. The generator doesn't need to yield - it's a lifecycle manager.

## Core Transformers (11 total)

### Stateful Transformers

**state** - Reactive state with `.state.value` getter/setter
**gate** - Flow control with `.gate.open()`, `.gate.close()`
**cache** - HOT caching with `.cache.values`, TTL, drop strategies

### Value Transformers

**filter** - Remove values based on predicate (sync/async, stateful)
**map** - Transform values (sync/async, stateful)
**flat** - Flatten arrays into individual values
**buffer** - Collect values into arrays of specified size

### Combination Transformers

**merge** - Combine multiple streams (union types)
**zip** - Combine streams pairwise (tuples)

### Utility Transformers

**branch** - Forward values to target stream (parallel observation)
**effect** - Side effects without transformation (identity map)

## Transformer Patterns

### Stateful Filter/Map

Both `filter` and `map` support stateful operations:

```typescript
// Stateful filter
filter<T, STATE>({ initialState }, (state, value) => {
  // Return undefined to terminate stream
  // Return [boolean, newState] to continue
  return [shouldPass, newState];
})

// Stateful map
map<T, STATE, U>({ initialState }, (state, value) => {
  return [mappedValue, newState];
})
```

### Async Generator Pattern (for complex transformers)

**When to use:**
- Timing-based operations (debounce, throttle, delay, window)
- Complex state management
- Need to push values asynchronously

**Pattern:**
```typescript
const transformer = <T>(config) => (source: Stream<T>) => {
  const output = new Stream<T>(async function* () {
    // State variables
    let state = initialState;

    // Iterate source
    for await (const value of source) {
      // Process value
      // Push to output when ready (can be async)
      output.push(processedValue);
    }

    // Cleanup
  });

  return output;
};
```

**Key features:**
- Lazy initialization (generator starts when output has listeners)
- Automatic cleanup (generator stops when listeners removed)
- Can push to output at any time (timers, intervals, etc.)
- Generator manages lifecycle, doesn't need to yield

## Strategy Options

`filter`, `map`, and `effect` support execution strategy options:

- **sequential** (default): Process one at a time on main thread
- **concurrent**: Process all concurrently on main thread, emit as completed (unordered)
- **concurrent-ordered**: Process all concurrently on main thread, maintain order
- **parallel**: Process in Web Workers, emit as completed (unordered)
- **parallel-ordered**: Process in Web Workers, maintain order

```typescript
// Main thread, ordered
stream.pipe(map(async (v) => await process(v), { 
  execution: 'concurrent-ordered' 
}))

// Workers, unordered (fastest)
stream.pipe(map((v) => heavyComputation(v), { 
  execution: 'parallel' 
}))

// Workers with args
stream.pipe(map((v, args) => v * args.multiplier, { 
  execution: 'parallel',
  args: { multiplier: 2 }
}))
```

## Worker Pool Architecture

### Overview

The library includes a singleton WorkerPool that manages Web Workers for CPU-intensive operations:

- **Shared pool**: 4 workers (configurable) shared across all streams
- **Function registration**: Functions registered once, not serialized per event
- **Automatic fallback**: Falls back to main thread if workers unavailable
- **Round-robin**: Load balancing across workers

### How It Works

```typescript
// Worker pool registers function once
const { execute } = WorkerPool.register(mapper, args);

// Only values sent per event
stream.listen((value) => {
  execute(value).then(result => output.push(result));
});
```

### Benefits

- ✅ Function serialized once (not per event)
- ✅ Args cached in workers
- ✅ Smaller messages (just value)
- ✅ Better performance for high-frequency streams
- ✅ No worker limit issues (pool manages resources)

### Composition Pattern

**Key insight**: `map` is the execution engine. Other transformers compose with it:

```typescript
// filter composes with map
export const filter = <T>(predicate, options) => (source) => {
  const mapped = source.pipe(
    map(async (value) => [value, await predicate(value)], options)
  );
  
  return new Stream(async function* () {
    for await (const [value, shouldPass] of mapped) {
      if (shouldPass) yield value;
    }
  });
};

// effect composes with map
export const effect = <T>(fn, options) => (source) => 
  source.pipe(map(async (value) => {
    await fn(value);
    return value;  // Identity
  }, options));
```

This means all execution strategies (sequential, concurrent, parallel) work automatically in filter and effect!

## Common Patterns

### Timing Patterns

```typescript
// Debounce - delay until quiet
const debounce = <T>(ms: number) => (source: Stream<T>) => {
  const output = new Stream<T>(async function* () {
    let timer: any = null;
    for await (const value of source) {
      clearTimeout(timer);
      timer = setTimeout(() => output.push(value), ms);
    }
  });
  return output;
};

// Delay - delay each value
const delay = <T>(ms: number) => (source: Stream<T>) =>
  new Stream<T>(async function* () {
    for await (const value of source) {
      await new Promise(resolve => setTimeout(resolve, ms));
      yield value;
    }
  });

// Window - time-based windowing
const window = <T>(ms: number) => (source: Stream<T>) => {
  const output = new Stream<T[]>(async function* () {
    let buffer: T[] = [];
    const flush = () => {
      if (buffer.length > 0) {
        output.push([...buffer]);
        buffer = [];
      }
    };
    const timer = setInterval(flush, ms);
    for await (const value of source) {
      buffer.push(value);
    }
    clearInterval(timer);
    flush();
  });
  return output;
};
```

### State Management Patterns

```typescript
// Take first N
const take = <T>(n: number) =>
  filter<T, { count: number }>({ count: 0 }, (state, value) => {
    if (state.count >= n) return;
    return [true, { count: state.count + 1 }];
  });

// Throttle (rate limit)
const throttle = <T>(ms: number) =>
  filter<T, { lastEmit: number }>({ lastEmit: 0 }, (state, value) => {
    const now = Date.now();
    if (now - state.lastEmit < ms) return [false, state];
    return [true, { lastEmit: now }];
  });

// Distinct (deduplicate)
const distinct = <T>() =>
  filter<T, { seen: Set<T> }>({ seen: new Set() }, (state, value) => {
    if (state.seen.has(value)) return [false, state];
    state.seen.add(value);
    return [true, state];
  });
```

## Design Principles

1. **Minimal primitives**: 2 primitives (Stream + pipe), 11 transformers
2. **Composability**: Build complex from simple
3. **Type safety**: Full TypeScript inference
4. **Lazy by default**: Transformers don't start until consumed
5. **Automatic cleanup**: WeakRef, AbortSignal, disposable pattern
6. **Efficient**: Transformers execute once per value, shared computation

## Creating New Transformers

### Decision Tree

1. **Can it be composed from existing transformers?**
   - Yes → Create as pattern using `filter`, `map`, etc.
   - No → Continue

2. **Does it need timing control or async state?**
   - Yes → Use async generator pattern
   - No → Continue

3. **Does it need special API (like `.state.value`)?**
   - Yes → Create as core transformer with extended type
   - No → Use async generator pattern

### Testing Checklist

- [ ] Basic functionality
- [ ] Edge cases (empty, single value, rapid emissions)
- [ ] Lazy initialization
- [ ] Cleanup (no memory leaks)
- [ ] Type safety

## Common Mistakes

1. **Don't iterate output in its own generator** - creates circular dependency
2. **Use `output.push()` not `yield`** - when you need async timing control
3. **Remember stateful operations are always sequential** - no strategy option
4. **Clean up timers/intervals** - in finally block or when generator stops
5. **Use WeakRef for DOM element contexts** - automatic cleanup on GC

## Examples

### Simple Pattern (Composable)

```typescript
// Skip first N values
export const skip = <T>(n: number) =>
  filter<T, { count: number }>({ count: 0 }, (state, value) => {
    const newCount = state.count + 1;
    return [newCount > n, { count: newCount }];
  });
```

### Complex Pattern (Async Generator)

```typescript
// Audit - emit first, ignore until quiet
export const audit = <T>(ms: number) => (source: Stream<T>) => {
  const output = new Stream<T>(async function* () {
    let timer: any = null;
    let canEmit = true;

    for await (const value of source) {
      if (canEmit) {
        output.push(value);
        canEmit = false;
        clearTimeout(timer);
        timer = setTimeout(() => (canEmit = true), ms);
      }
    }
  });

  return output;
};
```

### Core Transformer (Extended Type)

```typescript
type Gate<T> = Stream<T> & {
  gate: {
    open(): void;
    close(): void;
    readonly isOpen: boolean;
  };
};

export const gate = <T>(): Stream.Transformer<Stream<T>, Gate<T>> => {
  return (source: Stream<T>) => {
    let isOpen = true;
    
    const output = new Stream<T>(async function* () {
      for await (const value of source) {
        if (isOpen) yield value;
      }
    }) as Gate<T>;

    output.gate = {
      open: () => (isOpen = true),
      close: () => (isOpen = false),
      get isOpen() { return isOpen; }
    };

    return output;
  };
};
```

## File Structure

```
src/
  stream.ts              # Core Stream class
  transformers/
    state/
      state.ts           # Transformer implementation
      state.md           # Documentation
      state.test.ts      # Tests
    [transformer]/
      index.ts           # Export
patterns/
  [pattern]/
    [pattern].ts         # Pattern implementation
    [pattern].test.ts    # Tests
```

## Documentation Template

```typescript
/**
 * [One-line description]
 * 
 * @example
 * ```typescript
 * stream.pipe([pattern](args))
 * ```
 */
```

## This Context File

Use this file to:
- Understand library architecture
- Create new patterns/transformers
- Assist users with library usage
- Generate examples and documentation
- Debug issues

The library is designed for simplicity and composability. When in doubt, check if it can be composed from existing primitives before creating new ones.
